module Records
  module DSL
    Struct.class_eval do
      attr_accessor :index

      # why is this not available in Struct?
      def to_hash(clean = false)
        h = {}
        h[:index] = index
        each_pair do |name, value|
          if !clean or !self.class.internal_field?(name)
            h[name] = value
          end
        end
        h
      end
    end
  
    # methods mixed intno the Struct class generated by the DSL
    # to wrap the fields
    module StructMixin
      INTERNAL_FIELD_REGEX = /^_/
      
      # define some class methods
      def self.included(base)
        base.extend(ClassMethods)
      end

      # class methods on the struct
      module ClassMethods
        def internal_field?(name)
          name.to_s =~ INTERNAL_FIELD_REGEX
        end
        def read(file, filter = nil)
          bytes = file.read(self::SIZE)
          raise EOFError if bytes.nil?
          return parse(bytes, filter)
        end
        def parse(bytes, filter = nil)
          unpacked = bytes.unpack(self::FIELD_SPEC_STRING)
          if filter
            matched = filter.call(unpacked)
            return nil unless matched
          end
          
          struct = new(*unpacked)
        end
      end
      
      # pack the field values into an array, optionally generating missing values
      def pack(generate = false)
        vals = []
        # for each property, get the value
        # or generate one if there is a lambda/defaut value
        each_pair do |key, value|
          # if the value is nil and there is a lambda
          # generate it
          if generate and value.nil?
            l = self.class::LAMBDAS[key]
            if l
              if l.is_a?(Proc)
                # it's a proc. invoke it.
                value = l.call if l.is_a?(Proc)
              else
                value = l
              end
            end
          end
          # in general it would be inconsistent to flatten legitimate field values
          # (e.g. in case the value was actually nil or an array), however we know
          # that thse are never legitimate field values so it must have been
          # explicitly set in order to support composite fields (or the user is crazy)
          if !value.nil?
            if value.is_a?(Array)
              vals += value
            else
              vals << value
            end
          end
        end
        
        packed = vals.pack(self.class::FIELD_SPEC_STRING)
        raise "Packed struct size #{packed.length} does not match struct size: " + self.class::SIZE.to_s if packed.length != self.class::SIZE
        packed
      end
      
      # reset the intended length on any "pascal strings" (intended length may be shorter than field specifier max length)
      def normalize_pascal_strings
        #each_pair do |key, value|
        self.class::PASCAL_STRINGS.each do |key|
          len_field = PascalStringFields::pascal_string_len_field(key) 
          len = self[len_field] rescue nil 
          if !len.nil? and len.is_a?(Fixnum)
            value = self[key]
            value.slice!(len..-1)
            #self[key] = value # we can avoid reassignment assuming the value is a reference not a copy
          end
        end
        self
      end
    end

    # helper methods that are mixed into the DSL to support "pascal strings"
    # which are a pair of fields, length followed by string
    module PascalStringFields
      # add a pascal string field (pair)
      # spec is the full spec (with preceding 'c' for length)
      # limit can be used to truncate generated value
      def pascal_string(spec, name = next_unknown_field_name, data_lambda = nil, limit = nil)
        @field_specs << spec
        @pascal_strings ||= []
        @pascal_strings << name
        len_field, string_field = pascal_string_fields(name)
        add_field(len_field, nil)
        # have to turn it back into a pascal string!
        # so the proc here actually returns the values
        # for both the len, and the string
        # this will get flattened into the values list
        # when packing the struct
        add_field(string_field, Proc.new {
          val = data_lambda.call
          if limit
            val.slice!(limit..-1)
          end
          [ val.length, val ]
        })
      end
      
      # make the following methods utilities that are callable
      # on the module
      module_function

      # returns the internal field name used for the
      # pascal length field
      def pascal_string_len_field(name)
        "_#{name.to_s}_len".to_sym
      end

      # returns the names of the two fields that comprise the pascal field
      def pascal_string_fields(name)
        [ pascal_string_len_field(name.to_sym), name.to_sym ]
      end
    end

    # allows building of a struct that can marshal fields to and from bytes
    # based on string/array unpack/pack format specifier
    # fields may have lambdas which are used to generate values for nil fields
    # combination of specifier and lambdas can be used to create 'composite'
    # or virtual fields (e.g. pascal string type which is length byte followed
    # by string bytes)
    class StructDSL
      include PascalStringFields

      # dsl entry point
      def self.build(size, name = nil, &block)
        dsl = StructDSL.new(size, name)
        dsl.instance_eval(&block)
        dsl.to_struct_class
      end
      
      # constructor for struct metadata
      def initialize(size, name = nil)
        @size = size
        @name = name
        @field_specs = []
        @fields = []
        @lambdas = { }
        @unknown_inc = 0
      end
      
      # adds a field specifier to the struct metadata
      def field(spec, name = nil, data_lambda = nil)
        @field_specs << spec
        add_field(name, data_lambda)
      end

      # generates a struct class from the metadata
      def to_struct_class
        # flatten fields to handle the case where a helper has contributed a series of fields
        # in an array
        args = @fields.flatten
        # prepend the name if specified
        args = [ @name ] + args if @name
        
        # create an array.pack field specifier string from all the field specs
        field_spec_string = @field_specs.flatten.join(' ')
        
        # obtain the class for the arguments
        struct_class = self.class.create_struct_class(*args)
        
        # define metadata for this particular class
        struct_class.const_set("SIZE", @size)
        struct_class.const_set("FIELD_SPEC_STRING", field_spec_string)
        struct_class.const_set("LAMBDAS", @lambdas)
        struct_class.const_set("PASCAL_STRINGS", @pascal_strings)

        # create the struct class
        # mix in the record parse helpers
        struct_class.class_eval do
          include StructMixin
        end

        struct_class
      end
      
      # helper that truncates string return values
      # but mostly was an exercise in using Procs
      def self.limit_result(proc, len, *args)
        return Proc.new do
          result = proc.call(*args)
          if result
            result.slice!(len..-1)
          end
          result
        end
      end
    
      private
      
      # define a struct class for the given fields
      # args is: Name followed by field name symbols
      def self.create_struct_class(*args)
        #StaticHash.create_class(*args)
        Struct.new(*args)
        #LightweightStruct.create_class(*args)
      end
      
      # add a field name/lambda pair
      def add_field(name, data_lambda = nil)
        name = next_unknown_field_name if name.nil?
        @fields << name.to_sym
        @lambdas[name.to_sym] = data_lambda if data_lambda
      end
      
      # generate the next synthetic name for an anonymous field
      def next_unknown_field_name
        field_name = "_unknown" + @unknown_inc.to_s
        @unknown_inc += 1
        field_name.to_sym
      end
    end
  end
end